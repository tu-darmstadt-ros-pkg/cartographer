//
// Created by ubuntu on 20.02.21.
//
#include <cmath>
#include <chrono>
#include <thread>
#include <iomanip>
#include <cstdlib>
#include <ctime>

#include "dynamic_object_removal_points_processor.h"


namespace cartographer {
namespace io {

void WriteBinaryPlyHeader(const bool has_color, const bool has_intensities,
                          const std::vector<std::string>& comments,
                          const int64 num_points,
                          FileWriter* const file_writer) {
  const std::string color_header = !has_color ? ""
                                              : "property uchar red\n"
                                                "property uchar green\n"
                                                "property uchar blue\n";
  const std::string intensity_header =
      !has_intensities ? "" : "property float intensity\n";
  std::ostringstream stream;
  stream << "ply\n"
         << "format binary_little_endian 1.0\n"
         << "comment generated by Cartographer\n";
  for (const std::string& comment : comments) {
    stream << "comment " << comment << "\n";
  }
  stream << "element vertex " << std::setw(15) << std::setfill('0')
         << num_points << "\n"
         << "property float x\n"
         << "property float y\n"
         << "property float z\n"
         << color_header << intensity_header << "end_header\n";
  const std::string out = stream.str();
  CHECK(file_writer->WriteHeader(out.data(), out.size()));
}

void WriteBinaryPlyPointCoordinate(const Eigen::Vector3f& point,
                                   FileWriter* const file_writer) {
  // TODO(sirver): This ignores endianness.
  char buffer[12];
  memcpy(buffer, &point[0], sizeof(float));
  memcpy(buffer + 4, &point[1], sizeof(float));
  memcpy(buffer + 8, &point[2], sizeof(float));
  CHECK(file_writer->Write(buffer, 12));
}

std::unique_ptr<DynamicObjectsRemovalPointsProcessor> DynamicObjectsRemovalPointsProcessor::FromDictionary(
    const FileWriterFactory& file_writer_factory,
    common::LuaParameterDictionary *dictionary,
    PointsProcessor *next) {
  return absl::make_unique<DynamicObjectsRemovalPointsProcessor>(
      file_writer_factory(dictionary->GetString("filename")),
      dictionary->GetInt("r_segments"),
      dictionary->GetInt("theta_segments"),
      dictionary->GetInt("phi_segments"),
      dictionary->GetDouble("sensor_range_limit"),
      next);
}

DynamicObjectsRemovalPointsProcessor::DynamicObjectsRemovalPointsProcessor(std::unique_ptr<FileWriter> file_writer,
    const int r_segments, const int theta_segments, const int phi_segments, const float sensor_range_limit,
    PointsProcessor* next)
    : r_segments_(r_segments), theta_segments_(theta_segments),
    phi_segments_(phi_segments), sensor_range_limit_(sensor_range_limit), next_(next),
    file_(std::move(file_writer)) {
  LOG(INFO) << "Initialized Dynamic objects removal filter with:\n" <<
  "r_segments:         " << r_segments_ << "\n" <<
  "theta_segments:     " << theta_segments_ << "\n" <<
  "phi_segments:       " << phi_segments_ << "\n" <<
  "sensor_range_limit: " << sensor_range_limit_;
}

void DynamicObjectsRemovalPointsProcessor::Process(std::unique_ptr<PointsBatch> batch) {
  // For debugging: sleep at first iteration
  if (map_.empty()) {
    std::this_thread::sleep_for(std::chrono::seconds(10));
  }

  LOG(INFO) << "Iteration: " << list_of_batches_.size() + 1 << "\tBatch points: " << batch->points.size();
  // Create wedge for global map and current scan. Only if this isn't the first scan

  // Add the current batch to the list of batches for later sending
  list_of_batches_.push_back(*batch);
  LOG(INFO) << "Batch inserted";

  if (!map_.empty()) {
    wedge_map_t scan_wedge_map = create_wedge_map(batch->points);
    wedge_map_t global_wedge_map = create_wedge_map(sensor::TransformPointCloud(map_, batch->sensor_to_map.inverse()));

    LOG(INFO) << "Scan wedge map size: " << scan_wedge_map.size() << "\tGlobal wedge map size: " << global_wedge_map.size();

    // Test writing of points
    /*if (list_of_batches_.size() == 1) {
      std::srand(std::time(nullptr));
      sphercial_wedge wedge;
      float r_min = 0.0f;
      float r_max = r_min + sensor_range_limit_ / r_segments_;
      float theta_min = 0.0f;
      float theta_max = theta_min + M_PI / theta_segments_;
      float phi_min = 0.0f;
      float phi_max = phi_min + (2.0f * M_PI) / phi_segments_;

      for (int i = 0; i < 1000; ++i) {
        float r = r_min + static_cast<float>(rand()) / (static_cast <float> (RAND_MAX/(r_max-r_min)));
        float theta = theta_min + static_cast<float>(rand()) / (static_cast <float> (RAND_MAX/(theta_max-theta_min)));
        float phi = phi_min + static_cast<float>(rand()) / (static_cast <float> (RAND_MAX/(phi_max-phi_min)));
        sensor::RangefinderPoint coords;
        coords.position = polar_to_cartesian(r, theta, phi);
        wedge.wedge_points.push_back(coords);
      }

      std::vector<std::string> comments;

      WriteBinaryPlyHeader(false, false, comments, 0, file_.get());
      for (size_t i = 0; i < wedge.wedge_points.size(); ++i) {
        WriteBinaryPlyPointCoordinate(wedge.wedge_points[i].position, file_.get());
      }
      WriteBinaryPlyHeader(false, false, comments, wedge.wedge_points.size(),
                           file_.get());
      CHECK(file_->Close()) << "Closing PLY file_writer failed.";
    }*/

    // Dynamic objects detection
    for (auto &global_wedge : global_wedge_map) {
      wedge_key_t key = global_wedge.first;
      bool any_obj_detected = false;
      bool dyn_obj_detected = false;

      if (std::get<0>(key) + 1 < r_segments_) {
        // Iterate over all scan wedges with same theta and phi but increasing distance r starting at 0
        for (uint16_t new_r = 0; new_r < r_segments_; ++new_r) {
          wedge_key_t new_key = std::make_tuple(new_r, std::get<1>(key), std::get<2>(key));

          auto search = scan_wedge_map.find(new_key);
          if (search != scan_wedge_map.end()) {
            // Wedge exists
            any_obj_detected = true;
            // TODO(bhirschel) do a cardinality check, eg check how many points are in there
            if (new_r > std::get<0>(key)) {
              dyn_obj_detected = true;
              /* this means that the points belonging to key in the global wedge map are no longer
               * there in the current scan and therefore belong to an dynamic object that has moved
               */
            }
            break; // no need to continue searching as there cannot be more detections behind this
          }
        }
        // sensor range limit reached but no detection so far -> same as above
        if (!any_obj_detected) {
          dyn_obj_detected = true;
        }

        if (dyn_obj_detected) {
          // Remove from the global wedge map. Necessary for potential future iterations over this ray in this time segment
          //global_wedge_map.erase(key); // SEGFAULT
          // Remove from the global map
          remove_points_from_pointcloud(key, map_);
          // Remove from the list of batches
          for (auto &batch_iter : list_of_batches_) {
            remove_points_from_batch(key, batch_iter);
          }
        }
      }
    }
  }

  // Add all points from the current scan to the full map
  for (auto & point : batch->points) {
    map_.push_back(batch->sensor_to_map * point);
  }

  LOG(INFO) << "Total Map points: " << map_.size();

  // TODO(bhirschel) we want to process upon completion of the bag
  next_->Process(std::move(batch));
}

Eigen::Vector3f DynamicObjectsRemovalPointsProcessor::cartesian_to_polar(Eigen::Vector3f cart_coord) {
  Eigen::Vector3f polar_coord;

  polar_coord.x() = sqrt(pow(cart_coord.x(), 2.0f) +
      pow(cart_coord.y(), 2.0f) + pow(cart_coord.z(), 2.0f)); // represents r
  polar_coord.y() = acos(cart_coord.z() / polar_coord.x()); // represents theta betwwen 0 and pi
  polar_coord.z() = atan2(cart_coord.y(), cart_coord.x()) + M_PI; // represents phi between 0 and +2pi

  return polar_coord;
}

Eigen::Vector3f DynamicObjectsRemovalPointsProcessor::polar_to_cartesian(float r,
                                                                         float theta,
                                                                         float phi) {
  Eigen::Vector3f cart;

  cart.x() = r*sin(theta)*cos(phi);
  cart.y() = r*sin(theta)*sin(phi);
  cart.z() = r*cos(theta);

  return cart;
}

uint16_t DynamicObjectsRemovalPointsProcessor::cantor_pairing(uint16_t a, uint16_t b) {
  return ((a + b)*(a + b + 1))/2 + b;
}

DynamicObjectsRemovalPointsProcessor::wedge_key_t DynamicObjectsRemovalPointsProcessor::get_interval_segment(
    Eigen::Vector3f p) {
  float r, theta, phi;
  uint16_t r_seg, theta_seg, phi_seg;

  r = p.x();
  theta = static_cast<float>(fmod(p.y(), M_PI));
  phi = static_cast<float>(fmod(p.z(), 2.0f * M_PI));

  // Convert into positive space from 0 to pi or 0 to 2pi, respectively
  theta = theta < 0 ? theta + M_PIf : theta;
  phi = phi < 0 ? phi + 2.0f * M_PIf : phi;

  // Get index of the interval segment it belongs to
  r_seg = static_cast<uint16_t>(floorf(r / (sensor_range_limit_ / r_segments_)));
  theta_seg = static_cast<uint16_t>(floorf(theta / (M_PIf / theta_segments_)));
  phi_seg = static_cast<uint16_t>(floorf(phi / ((2.0f * M_PIf) / phi_segments_)));

  return std::make_tuple(r_seg, theta_seg, phi_seg);
}

DynamicObjectsRemovalPointsProcessor::wedge_map_t DynamicObjectsRemovalPointsProcessor::create_wedge_map(
    sensor::PointCloud cloud) {
  wedge_map_t wedge_map;

  for (auto & p : cloud) {
    Eigen::Vector3f polar = cartesian_to_polar(p.position);

    // Skip if distance is greater than the sensor range limit
    if (polar.x() > sensor_range_limit_) {
      continue;
    }

    wedge_key_t key = get_interval_segment(polar);
    auto search = wedge_map.find(key);
    if (search == wedge_map.end()) {
      // No such element existed before
      sphercial_wedge wedge;
      wedge.wedge_points.push_back(p);
      wedge_map[key] = wedge;
    } else {
      // This wedge already exists, add point to the pointcloud
      search->second.wedge_points.push_back(p);
    }
  }

  return wedge_map;
}

PointsProcessor::FlushResult DynamicObjectsRemovalPointsProcessor::Flush() {
  return next_->Flush();
}

void DynamicObjectsRemovalPointsProcessor::remove_points_from_pointcloud(
    DynamicObjectsRemovalPointsProcessor::wedge_key_t key,
    sensor::PointCloud& cloud) {
  absl::flat_hash_set<int> to_remove;

  for (size_t i = 0; i < cloud.size(); ++i) {
    auto p = cloud[i].position;
    wedge_key_t local_key = get_interval_segment(cartesian_to_polar(p));
    if (key == local_key) {
      to_remove.insert(i);
    }
  }

  const size_t new_num_points = cloud.size() - to_remove.size();
  sensor::PointCloud points;
  points.reserve(new_num_points);
  for (size_t i = 0; i < cloud.size(); ++i) {
    if (to_remove.count(i) == 1) {
      continue;
    }
    points.push_back(cloud[i]);
  }
  cloud = std::move(points);

  LOG(INFO) << "Removed from global map: " << to_remove.size() << " points";
}
void DynamicObjectsRemovalPointsProcessor::remove_points_from_batch(
    DynamicObjectsRemovalPointsProcessor::wedge_key_t key,
    PointsBatch &batch) {
  absl::flat_hash_set<int> to_remove;

  for (size_t i = 0; i < batch.points.size(); ++i) {
    wedge_key_t local_key = get_interval_segment(cartesian_to_polar(batch.points[i].position));
    if (key == local_key) {
      to_remove.insert(i);
    }
  }

  RemovePoints(to_remove, &batch);

  LOG(INFO) << "Removed from local batch: " << to_remove.size() << " points";
}
}
}
